# 数的分解

把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。

```c++
#include<bits/stdc++.h> 
using namespace std;

bool papi(int n){
	while(n){
		if(n%10==4||n%10==2) return false;
		n/=10;
	}
	return true;
}

int main() {
	int num=0;
	for(int i=1;i<2018;i++){
    	for(int j=i+1;j<2018;j++){
    		for(int t=j+1;t<2018;t++){
    			if((i+j+t)==2019)
    				if(papi(i)&&papi(j)&&papi(t))
						num++;
			}
		}
	}
	cout<<num;
    return 0;
}
```



# 特别数的和

```c++
#include<bits/stdc++.h>
using namespace std;

bool papi(int n){
    string a=to_string(n);
    for(int i=0;i<a.length();i++){
        int t=a[i]-'0';
        if(t==2||t==0||t==1||t==9) return true;
    }
    return false;
}

int main(){
    int sum=0,n;
    cin>>n;
    for(int i=1;i<=n;i++){
        if(papi(i)) sum+=i;
    }
	cout<<sum;
    return 0;
}
```

# 完全二叉树的权值

时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分 【问题描述】 给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A 1 , A 2 , ··· A N ，如下图所示： 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：根的深度是 1。 【输入格式】 第一行包含一个整数 N。 第二行包含 N 个整数 A 1 , A 2 , ··· A N 。 【输出格式】 输出一个整数代表答案。 【样例输入】 7 1 6 5 4 3 2 1 试题G: 完全二叉树的权值 10 第十届蓝桥杯大赛软件类省赛 C/C++ 大学 B 组 【样例输出】 2 【评测用例规模与约定】 对于所有评测用例，1 ≤ N ≤ 100000，−100000 ≤ A i ≤ 100000。

```c++
#include <iostream>
using namespace std;
int getdeep(int n){
    int ret=0;
    while(n>0){
        n/=2;
        ret+=1;
    }
    return ret;
}
int main() {
	int num;
	cin>>num;
    int out[20];
    fill(out,out+20,0);
    int max=0;
    int degree=0;
    for(int i=1;i<=num;i++){
        int t;
        cin>>t;
        int de=getdeep(i);
        out[de]+=t;
        //cout<<"put"<<t<<"in the "<<de<<"degree"<<endl;
        if(out[de]>max){
        	 degree=de;
        	 max=out[de];
		}
    }
    cout<<degree;
	return 0;
}
```



# 等差数列

![image-20201013100750643](%E8%93%9D%E6%A1%A5.assets/image-20201013100750643.png)

```c++
#include<cassert>
#include<algorithm>
#include <iostream>
using namespace std;

int main() {
	int num;
	cin>>num;
	vector<int> list;
	for(int i=0;i<num;i++){
		int t;
		cin>>t;
		list.push_back(t);
	} 
	vector<int>::iterator it_1=list.begin();
	vector<int>::iterator it_2=list.end();
	sort(it_1,it_2);
	vector<int>::iterator new_end=unique(it_1,it_2);
	list.erase(new_end,it_2);
	
//	for(int i=0;i<list.size();i++){
//		cout<<list[i]<<"	"<<endl;
//	}
	vector<int> gap;
	for(int i=0;i<list.size()-1;i++){
		gap.push_back(list[i+1]-list[i]);
		//cout<<"^^"<<list[i+1]-list[i]<<"^^^"<<endl;
	}
	sort(gap.begin(),gap.end());
	int out;
	for(int i=gap[0];i>=1;i--){
		bool flag=true;
		for(int j=1;j<gap.size();j++){
			if(gap[j]%i!=0){
				 flag=false;
				 break;
			}
		}
		if(flag){
			out=i;
			break;
		}
	}
	cout<<(list[list.size()-1]-list[0])/out+1;
	return 0;
}
```

# NOJ组合输出

**Description:**

排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素（不分顺序且r<=n），我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。现要求你输出所有组合。例如n=5，r=3，所有组合为：

1 2 3 1 2 4 1 2 5 1 3 4  1 3 5  1 4 5 2 3 4  2 3 5 2 4 5  3 4 5

**Input:**

一行两个自然数n、r（1<n<21,1<=r<=n）。

**Output:**

所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，要求所有组合也按字典顺序。

**Sample Input:**

```
5 3
```

**Sample Output:**

```
  1  2  3
  1  2  4
  1  2  5
  1  3  4
  1  3  5
  1  4  5
  2  3  4
  2  3  5
  2  4  5
  3  4  5
```

这是我的超时代码![image-20201016000604175](%E8%93%9D%E6%A1%A5.assets/image-20201016000604175.png)

```c++
#include<bits/stdc++.h>

using namespace std;

int n,r;
int li[22];
vector<int> out;
void dfs(int num,int degree){
    li[degree]=num;
    if(degree==r){
        for(int i=1;i<=r;i++) out.push_back(li[i]);
        return;
    }
    if((num+r-degree)<r) return;
    for(int i=num+1;i<=n;i++){
     dfs(i,degree+1);   
    }
}

int main(){
    cin>>n>>r;
    dfs(0,0);
    for(int i=0;i<out.size();i++){
        cout<<out[i];
        if((i+1)%r==0&&i!=out.size()-1) cout<<endl;
        else if((i+1)%r!=0) cout<<"  ";
    }
}
```

这是砍掉vector后AC的![image-20201016000637368](%E8%93%9D%E6%A1%A5.assets/image-20201016000637368.png)

```c++
#include<bits/stdc++.h>
using namespace std;
int n,r;
int li[22];
void dfs(int num,int degree){
    li[degree]=num;
    if(degree==r){
        for(int i=1;i<r;i++)
        printf("%d ",li[i]);
        printf("%d\n",li[r]);
    }
    if((num+r-degree)<r) return;
    for(int i=num+1;i<=n;i++){
     dfs(i,degree+1);   
    }
}
int main(){
    cin>>n>>r;
    dfs(0,0);
}
```

这是参考代码![image-20201016000934813](%E8%93%9D%E6%A1%A5.assets/image-20201016000934813.png)

```c++
#include <cstdio>
const int maxn=100010;
int a[maxn],n,r;
void dfs(int num,int it)
{
    int i=1,j;
    a[it]=num;
    if(it==r)
    {
        for(i=1;i<r;i++)
        printf("%d ",a[i]);
        printf("%d\n",a[r]);
    }
    else
    {
        for(i=num+1;i<=n;i++)
        {           
            dfs(i,it+1);
        }
    }       
}

int main()
{
    scanf("%d%d",&n,&r);
    for(int i=1;i<=n-r+1;i++) 
    dfs(i,1);
    return 0;
}
```

不用dfs

```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a[25],b[25];
    int n,r;
    scanf("%d%d",&n,&r);
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    for(int i=0;i<r;i++)
        a[i]=1;
    for(int i=0;i<n;i++)
        b[i]=i+1;
    for(int i=0;i<r-1;i++)
        //printf("%3d",b[i]);
        cout<<b[i]<<"  ";
    cout<<b[r-1];
    printf("\n");
    while(prev_permutation(a,a+n))
    {
        for(int i=0;i<n;i++){
        	int t=1;
            if(a[i]&&t!=r){
                printf("%d  ",b[i]);
                t++; 
        	}
        	else if(a[i]&&t==r) cout<<b[i];
        }
        
        printf("\n");
    }
    return 0;
}
```

# 递增三元组

ye自己写的dfs，把yenb坏了（淦 超时了

```c++
#include<stdio.h>
#include<iostream>
using namespace std;
int li[4];//输出元组 
int mc[3][100001];		//ABC矩阵 
int N;
int total=0;
void dfs(int num,int dg){
	if(dg!=0) li[dg]=mc[dg-1][num];
	if(dg>1&&li[dg]<=li[dg-1]){
		//cout<<"剪枝了！！"<<endl; 
		return;	
	}
	if(dg==3){
		//for(int i=1;i<4;i++) num++;
		total++;
		//cout<<"total++了一下"<<endl;
		return;
	}
	for(int i=0;i<N;i++){
		//cout<<"num==="<<num<<"dg==="<<dg<<endl;
		dfs(i,dg+1);
	}
}

int main()
{	
	cin>>N;
	for(int i=0;i<3;i++){
		for(int j=0;j<N;j++) cin>>mc[i][j];
	}
	dfs(0,0);
	cout<<"total===="<<total;
	return 0;
}

```

别人的

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
int a[MAXN],b[MAXN],c[MAXN];
int n,sum;

int main()
{
  cin>>n;
  for(int i=0;i<n;i++)scanf("%d",&a[i]);
  for(int i=0;i<n;i++)scanf("%d",&b[i]);
  for(int i=0;i<n;i++)scanf("%d",&c[i]);
  sort(a,a+n);
  sort(b,b+n);
  sort(c,c+n);
  sum = 0;
  for(int i=0;i<n;i++){
    int x = (lower_bound(a,a+n,b[i]) - a);
    int y = (n - (upper_bound(c,c+n,b[i]) - c));
    sum += x*y;
  }
  cout<<sum;
  return 0;
}
```

# 凑算式

用到了next_permutation()

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int li[9],total=0;
    for(int i=0;i<9;i++) li[i]=i+1;
	do{
		double t=(double)li[0]+(double)li[1]/li[2]+(double)(li[3]*100+li[4]*10+li[5])/(li[6]*100+li[7]*10+li[8]);
		//int t=li[0]+li[1]/li[2]+(li[3]*100+li[4]*10+li[5])/(li[6]*100+li[7]*10+li[8]);
		if(t==10){
			//cout<<li[0]<<li[1]<<li[2]<<li[3]<<li[4]<<li[5]<<li[6]<<li[7]<<li[8]<<endl;
			total++;
		}
	}while(next_permutation(li,li+9));
	cout<<total;
	return 0;
}
```

# 激光样式

x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。
安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！
国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？

显然，如果只有3台机器，一共可以成5种样式，即：
全都关上（sorry, 此时无声胜有声，这也算一种）
开一台，共3种
开两台，只1种

30台就不好算了，国王只好请你帮忙了。
要求提交一个整数，表示30台激光器能形成的样式种数。
注意，只提交一个整数，不要填写任何多余的内容。

```c++
#include<bits/stdc++.h>
using namespace std;
int sum=0;
void dfs(int deg,int r){
	if(deg==30){
		sum++;
		return;
	}
	/*if(r==1) dfs(deg+1,0);
	else 
	for(int i=0;i<2;i++){
		dfs(deg+1,i);
	}*/
    dfs(deg+1,0);
    if(r!=1) dfs(deg+1,1);
	
}

int main(){
	dfs(0,0);
	cout<<"sum==="<<sum;
	return 0;
}
```

# 最优包含

![image-20201113155704063](%E8%93%9D%E6%A1%A5.assets/image-20201113155704063.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 100000;

int main() {
	int n,k;
	cin>>n>>k;
	int li[n+1];
	for(int i=0;i<=n;i++) li[i]=i;
	ll tot=0;
	do{
		int t=0;bool flag=true;
		for(int i=2;i<n;i++){
			if(li[i]>li[i-1]&&li[i]>li[i+1]) t++;
			else if(li[i]<li[i-1]&&li[i]<li[i+1]) t++;
			if(t>k-1){
				flag=false;
				break;
			}
		}
		if(flag&&t==k-1){
			tot++;
			//for(int i:li) cout<<i<<"  ";
			//cout<<"t==="<<t<<endl;
		}
	}while(next_permutation(li,li+n+1));
	printf("%lld",tot%123456);
	return 0;
}
```

