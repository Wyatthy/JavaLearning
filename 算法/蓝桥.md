# 数的分解

把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。

```c++
#include<bits/stdc++.h> 
using namespace std;

bool papi(int n){
	while(n){
		if(n%10==4||n%10==2) return false;
		n/=10;
	}
	return true;
}

int main() {
	int num=0;
	for(int i=1;i<2018;i++){
    	for(int j=i+1;j<2018;j++){
    		for(int t=j+1;t<2018;t++){
    			if((i+j+t)==2019)
    				if(papi(i)&&papi(j)&&papi(t))
						num++;
			}
		}
	}
	cout<<num;
    return 0;
}
```



# 特别数的和

```c++
#include<bits/stdc++.h>
using namespace std;

bool papi(int n){
    string a=to_string(n);
    for(int i=0;i<a.length();i++){
        int t=a[i]-'0';
        if(t==2||t==0||t==1||t==9) return true;
    }
    return false;
}

int main(){
    int sum=0,n;
    cin>>n;
    for(int i=1;i<=n;i++){
        if(papi(i)) sum+=i;
    }
	cout<<sum;
    return 0;
}
```

# 完全二叉树的权值

时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分 【问题描述】 给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A 1 , A 2 , ··· A N ，如下图所示： 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：根的深度是 1。 【输入格式】 第一行包含一个整数 N。 第二行包含 N 个整数 A 1 , A 2 , ··· A N 。 【输出格式】 输出一个整数代表答案。 【样例输入】 7 1 6 5 4 3 2 1 试题G: 完全二叉树的权值 10 第十届蓝桥杯大赛软件类省赛 C/C++ 大学 B 组 【样例输出】 2 【评测用例规模与约定】 对于所有评测用例，1 ≤ N ≤ 100000，−100000 ≤ A i ≤ 100000。

```c++
#include <iostream>
using namespace std;
int getdeep(int n){
    int ret=0;
    while(n>0){
        n/=2;
        ret+=1;
    }
    return ret;
}
int main() {
	int num;
	cin>>num;
    int out[20];
    fill(out,out+20,0);
    int max=0;
    int degree=0;
    for(int i=1;i<=num;i++){
        int t;
        cin>>t;
        int de=getdeep(i);
        out[de]+=t;
        //cout<<"put"<<t<<"in the "<<de<<"degree"<<endl;
        if(out[de]>max){
        	 degree=de;
        	 max=out[de];
		}
    }
    cout<<degree;
	return 0;
}
```



# 等差数列

![image-20201013100750643](%E8%93%9D%E6%A1%A5.assets/image-20201013100750643.png)

```c++
#include<cassert>
#include<algorithm>
#include <iostream>
using namespace std;

int main() {
	int num;
	cin>>num;
	vector<int> list;
	for(int i=0;i<num;i++){
		int t;
		cin>>t;
		list.push_back(t);
	} 
	vector<int>::iterator it_1=list.begin();
	vector<int>::iterator it_2=list.end();
	sort(it_1,it_2);
	vector<int>::iterator new_end=unique(it_1,it_2);
	list.erase(new_end,it_2);
	
//	for(int i=0;i<list.size();i++){
//		cout<<list[i]<<"	"<<endl;
//	}
	vector<int> gap;
	for(int i=0;i<list.size()-1;i++){
		gap.push_back(list[i+1]-list[i]);
		//cout<<"^^"<<list[i+1]-list[i]<<"^^^"<<endl;
	}
	sort(gap.begin(),gap.end());
	int out;
	for(int i=gap[0];i>=1;i--){
		bool flag=true;
		for(int j=1;j<gap.size();j++){
			if(gap[j]%i!=0){
				 flag=false;
				 break;
			}
		}
		if(flag){
			out=i;
			break;
		}
	}
	cout<<(list[list.size()-1]-list[0])/out+1;
	return 0;
}
```

